# PL/0 编译器

```text
rust 1.85 nightly
```

## PL/0 语法

```ebnf
program = { statement } ;

statement = [ "// ..."
            | "const" identifier "=" integer { "," ident "=" integer }
            | "var" identifier [= integer] { "," ident [= integer]}
            | fn identifier "(" { identifier } ")" block-statement
            | identifier ("=" | "+=" | "-=" | "*=" | "/=") expression
            | "return" [ expression ]
            | expression
            ] [ ";" ] ;

block-statement = "{" {statement} "}" ;

expression = identifierifier
            | integer
            | ( "!" | "-" ) expression
            | expression ("+"|"-"|"*"|"/"|"<="|">="|"<"|">"|"=="|"!=") expression
            | if expression block-statement [ else block-statement ]
            | while expression block-statement
            | identifierifier "(" expression, {expression} ")" ;

identifier = { "a".."z" | "_" }
integer =  { "0".."9" }
```

###

程序由语句构成 其中表达式也是一种语句(只不过是结尾可以跟上分号). 其中 `const` `var` `fn` 定义, 不会存在于最终的目标代码中, 也可以算是 所有的语句都有返回值.

- 注释不会存在于 抽象语法树 中, 会被直接忽略。
- const 声明语句：声明时必须设置初值, 可以用 逗号分隔多个声明。
- var 声明语句：声明时 初值 是可选的（如果不设置初值则为 0）, 可以用 逗号分隔多个声明。
- 赋值语句：
  普通的赋值：=
  其余的赋值，都是在语法解析阶段，将其修改为相应表达式计算，然后赋值。（eg: a += 1 => a = a + 1）
- 返回语句：如果给定 表达式，则返回给定表达式的结果，如果没给定则返回 0；

  其虚拟机实现：压栈表达式的结果（没给定表达式则 将 0 压栈）, 取出栈顶值，然后想原 pl0 虚拟机那样，设置相应寄存器的值，然后将取出的栈顶值压回栈中

  todo: 图

表达式:

- ident: 向原 pl0 一样, 支持 A-Za-z 的字符
- integer：整数
- infix: 中缀表达式

  支持四则运算（+,-,\*,/），支持比较表达式（<,>,<=,>=,==,!=）

- if 表达式：

  支持 else 分支，每一个分支是一个语句块 这是为了防止`if 1 if 0 else 3`这样的语句出现。每一个分支都会返回值：分支最后一条表达式的值， 如果 该分支不存在或者分支语句块没有任何语句(为了支持这种情况， 我们在每一次分支开始的时候，压栈一个 0)则返回 0,

- while 表达式：为了满足表达式的要求 在原 pl0 基础上，在执行完 while 后返回 0

- 函数定义表达式：

  因为表达式是可以随处定义的， 为了防止在没调用的误入函数内部，在生成目标代码时，在函数代码块开始加一条 JMP 指定，跳转到函数结束.

  函数内变量也向 原 pl0，在 call 函数的时候，给函数内部的所有变量都分配空间，然后根据偏移地址来读写变量。

  函数支持外部传参，在函数内部，也可以定义变量，变量的偏移值 是`3 + index`, 函数参数与函数内变量相似（只是偏移值变成了，`-1 - index`）

- 函数调用表达式

  将函数分为内建函数与用户自定义函数, 其调用形式是一样的 (eg: `func()` ), 为了支持 内建函数, 我们增加了一个 虚拟机指令`Builtin(id, argc)`,

  函数调用作为表达式, 意味着也会有会返回值, 通过 `return` 关键字显式返回值, 如果没有隐式返回, 则默认返回 最后一条表达式语句的值, 如果函数体中没有语句(这里的处理类似 if while),则返回 0

  为了支持 函数传参, 我们需要 在调用前 将参数压栈, 这样，我们 call 函数时就可以通过（`-1 - index`）来获取参数了。然后为了在函数调用后清理 调用函数前传入的实参，我们需要增加一条虚拟机指令 `CallClean(arc)`, 来将实参弹栈。

  ps：原本想法是，可以调用任何可以返回函数起始地址的表达式，但发现这样好像没法处理 静态链问题（也就是，没法获取上层作用域的变量）, 故这里只能是调用函数名了。

### 函数语句块作用域

这包括 `if..else` `while` 表达式的语句块, 由于函数局部变量地址是在编译时期就确定了的, 增加语句块的作用域是为了尽量减少不必要的内存分配(maybe). 当然主要是为了防止，

```
if 1 {
  var a = 1; //
} else {
  a = 2; // 这里需要报错，a 并没有定义。
}
```

支持这个的做法就是：再进入该语句块时 `level + 1` 离开语句块时 `level - 1`, 类似于进入函数块那样，但是，作用域只需要 静态链

### 错误提示

由于该实现并没有 原 pl0 的短语层恢复， 故在语法解析阶段，如果说有错误就立即停止解析
但是在语义解析与目标代码生成阶段，发生错误，不会立即停止解析，依然会继续解析，最后再返回所有的错误。

### 语法解析

词法分析 $->$ 语法分析 $->$ 抽象语法树 $->$ 语义分析与目标代码生成

语法分析 中的 表达式分析 采用普拉特语法分析 （基于运算符优先级的自上而下的语法解析）。
那么操作符的优先级参考的时 [C 语言运算符优先级(https://zh.cppreference.com/w/c/language/operator_precedence)](https://zh.cppreference.com/w/c/language/operator_precedence)。

## 测试用例
